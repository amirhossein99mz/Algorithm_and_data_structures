Basic Concepts of Dynamic Memory in C

‚ùì Question:
How can we make dynamically allocated memory accessible outside the function where it was created?

‚úÖ Solution 1: Global Pointer (‚ùå not recommended):

#include <stdio.h>
#include <stdlib.h>

int *global_array = NULL;   // global pointer

void allocate_and_read(int count) {
    global_array = malloc(count * sizeof(int));
    for (int i = 0; i < count; i++) scanf("%d", &global_array[i]);
}

int main() {
    int size = 3;
    allocate_and_read(size);
    for (int i = 0; i < size; i++) printf("%d ", global_array[i]);
    free(global_array);
}
‚ùå Works, but unsafe design (global variable).

‚úÖ Solution 2: Return Pointer:

#include <stdio.h>
#include <stdlib.h>

int* allocate_and_read(int count) {
    int *array = malloc(count * sizeof(int));
    for (int i = 0; i < count; i++) scanf("%d", &array[i]);
    return array;
}

int main() {
    int size = 3;
    int *numbers = allocate_and_read(size);
    for (int i = 0; i < size; i++) printf("%d ", numbers[i]);
    free(numbers);
}
‚úÖ Clean, good when returning a single pointer.

‚úÖ Solution 3: Pass by Reference (Best & Most Flexible):

#include <stdio.h>
#include <stdlib.h>

void allocate_and_read(int **ptr, int count) {
    *ptr = malloc(count * sizeof(int));
    for (int i = 0; i < count; i++) scanf("%d", &(*ptr)[i]);
}

int main() {
    int size = 3;
    int *numbers = NULL;
    allocate_and_read(&numbers, size);
    for (int i = 0; i < size; i++) printf("%d ", numbers[i]);
    free(numbers);
}

‚úÖ Best approach: modular, flexible, avoids globals.

üëâ Summary

Solution 1 ‚Üí Global pointer ‚Üí ‚ùå bad practice.

Solution 2 ‚Üí Return pointer ‚Üí ‚úÖ fine for simple cases.

Solution 3 ‚Üí Pass pointer by reference ‚Üí ‚úÖ best for flexibility and modularity.
